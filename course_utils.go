package main

import (
	"fmt"
	"log"
	"strings"
)

// FindCourseByHash looks up a course by its hash value
func FindCourseByHash(hash string) (*CourseDB, error) {
	if DB == nil {
		return nil, fmt.Errorf("database not initialized")
	}

	var course CourseDB
	result := DB.Where("hash = ?", hash).First(&course)

	if result.Error != nil {
		return nil, result.Error
	}

	return &course, nil
}

// CheckCourseExists checks if a course with the given name and address already exists
func CheckCourseExists(name, address string) (bool, *CourseDB, error) {
	hash := GenerateCourseHash(name, address)
	course, err := FindCourseByHash(hash)

	if err != nil {
		// If record not found, that's not an error for this function
		return false, nil, nil
	}

	return true, course, nil
}

// CreateCourseWithHash creates a new course and automatically generates its hash
func CreateCourseWithHash(name, address, courseData string, createdBy *uint) (*CourseDB, error) {
	if DB == nil {
		return nil, fmt.Errorf("database not initialized")
	}

	// Check if course already exists
	exists, existingCourse, err := CheckCourseExists(name, address)
	if err != nil {
		return nil, fmt.Errorf("error checking for existing course: %v", err)
	}

	if exists {
		return existingCourse, fmt.Errorf("course already exists with hash: %s", existingCourse.Hash)
	}

	// Create new course (hash will be auto-generated by BeforeCreate hook)
	course := CourseDB{
		Name:       name,
		Address:    address,
		CourseData: courseData,
		CreatedBy:  createdBy,
		UpdatedBy:  createdBy,
	}

	result := DB.Create(&course)
	if result.Error != nil {
		return nil, fmt.Errorf("error creating course: %v", result.Error)
	}

	log.Printf("âœ… Created course: %s (hash: %s)", name, course.Hash)
	return &course, nil
}

// GetAllCourseHashes returns a map of all existing course hashes for deduplication
func GetAllCourseHashes() (map[string]bool, error) {
	if DB == nil {
		return nil, fmt.Errorf("database not initialized")
	}

	var courses []CourseDB
	result := DB.Select("hash").Find(&courses)

	if result.Error != nil {
		return nil, result.Error
	}

	hashMap := make(map[string]bool)
	for _, course := range courses {
		hashMap[course.Hash] = true
	}

	return hashMap, nil
}

// PreviewCourseHash generates and returns the hash that would be created for given name/address
// Useful for debugging or previewing before insertion
func PreviewCourseHash(name, address string) string {
	return GenerateCourseHash(name, address)
}

// ValidateAndNormalizeCourseData validates course data and returns normalized values
func ValidateAndNormalizeCourseData(name, address string) (string, string, error) {
	if name == "" {
		return "", "", fmt.Errorf("course name cannot be empty")
	}

	if address == "" {
		return "", "", fmt.Errorf("course address cannot be empty")
	}

	// Basic normalization (you can expand this)
	normalizedName := strings.TrimSpace(name)
	normalizedAddress := strings.TrimSpace(address)

	return normalizedName, normalizedAddress, nil
}
