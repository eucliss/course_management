# Golf Course Hash System

This system adds a unique hash identifier to each golf course based on the course name and address. This provides several benefits:

## ✨ Features

- **Automatic Hash Generation**: Hashes are automatically generated when creating courses
- **Duplicate Prevention**: Prevents duplicate courses from being added to the database
- **Normalization**: Handles variations in course names and addresses intelligently
- **Database Integration**: Seamlessly works with GORM and PostgreSQL
- **Web Scraper Integration**: Perfect for deduplicating scraped data

## 🏗️ How It Works

### Hash Generation Process

1. **Normalize** course name and address (lowercase, remove punctuation, standardize abbreviations)
2. **Combine** normalized strings with a separator: `normalized_name|normalized_address`
3. **Hash** using SHA256 and return first 16 characters (64-bit equivalent)

### Example Hash Generation

```go
name := "Pebble Beach Golf Course"
address := "1700 17-Mile Drive, Pebble Beach, CA 93953"
hash := GenerateCourseHash(name, address)
// Result: "aba6307ffadd5040"
```

### Normalization Examples

| Original | Normalized |
|----------|------------|
| `"Pebble Beach Golf Course"` | `"pebble beach gc"` |
| `"PEBBLE BEACH GOLF CLUB"` | `"pebble beach gc"` |
| `"Pebble Beach G.C."` | `"pebble beach gc"` |
| `"123 Main Street"` | `"123 main st"` |
| `"123 Main St."` | `"123 main st"` |

## 🗄️ Database Schema

The `CourseDB` struct includes a hash field:

```go
type CourseDB struct {
    ID         uint   `gorm:"primaryKey" json:"id"`
    Name       string `gorm:"not null" json:"name"`
    Address    string `json:"address"`
    Hash       string `gorm:"uniqueIndex;not null" json:"hash"` // Unique hash
    CourseData string `gorm:"type:jsonb" json:"course_data"`
    // ... other fields
}
```

## 🚀 Usage Examples

### 1. Basic Course Creation

```go
// The hash is automatically generated
course := CourseDB{
    Name:    "Augusta National Golf Club",
    Address: "2604 Washington Rd, Augusta, GA 30904",
    // Hash will be auto-generated by BeforeCreate hook
}

DB.Create(&course)
fmt.Printf("Course created with hash: %s", course.Hash)
```

### 2. Check for Duplicates Before Creating

```go
name := "Pebble Beach Golf Links"
address := "1700 17-Mile Drive, Pebble Beach, CA 93953"

exists, existingCourse, err := CheckCourseExists(name, address)
if exists {
    fmt.Printf("Course already exists: %s", existingCourse.Hash)
} else {
    // Safe to create new course
    course, err := CreateCourseWithHash(name, address, courseData, userID)
}
```

### 3. Find Course by Hash

```go
course, err := FindCourseByHash("aba6307ffadd5040")
if err != nil {
    fmt.Printf("Course not found")
} else {
    fmt.Printf("Found: %s", course.Name)
}
```

### 4. Preview Hash Before Creating

```go
hash := PreviewCourseHash("Pine Valley Golf Club", "Pine Valley, NJ 08021")
fmt.Printf("Would generate hash: %s", hash)
```

## 🕷️ Web Scraper Integration

Perfect for processing scraped golf course data:

```go
// Your scraped course structure
type ScrapedCourse struct {
    Name    string `json:"course_name"`
    Address string `json:"address"`
}

// Process scraped courses with automatic deduplication
func ProcessScrapedCourses(filename string) error {
    // Load existing hashes to avoid duplicates
    existingHashes, _ := GetAllCourseHashes()
    
    // Process each scraped course
    for _, course := range scrapedCourses {
        hash := GenerateCourseHash(course.Name, course.Address)
        
        if existingHashes[hash] {
            log.Printf("Skipping duplicate: %s", course.Name)
            continue
        }
        
        // Create new course
        CreateCourseWithHash(course.Name, course.Address, courseData, nil)
        existingHashes[hash] = true // Track for this batch
    }
}
```

## 🧪 Testing

Run the hash system tests:

```bash
# Test hash generation and normalization
go run test_hash.go database.go

# Test scraper integration
go run scraper_integration_example.go database.go course_utils.go
```

## 🔧 Available Functions

### Core Functions

- `GenerateCourseHash(name, address string) string` - Generate hash for given name/address
- `normalizeString(s string) string` - Normalize a string for hashing

### Database Functions

- `FindCourseByHash(hash string) (*CourseDB, error)` - Find course by hash
- `CheckCourseExists(name, address string) (bool, *CourseDB, error)` - Check if course exists
- `CreateCourseWithHash(name, address, courseData string, createdBy *uint) (*CourseDB, error)` - Create course with duplicate checking
- `GetAllCourseHashes() (map[string]bool, error)` - Get all existing hashes

### Utility Functions

- `PreviewCourseHash(name, address string) string` - Preview hash without creating
- `ValidateAndNormalizeCourseData(name, address string) (string, string, error)` - Validate input data

## 🏷️ GORM Hooks

The system uses GORM hooks for automatic hash management:

- **BeforeCreate**: Automatically generates hash if not set
- **BeforeUpdate**: Regenerates hash if name or address changes

## 🎯 Benefits

1. **Prevents Duplicates**: Unique constraint on hash prevents duplicate courses
2. **Handles Variations**: Normalization catches different formats of the same course
3. **Fast Lookups**: Hash-based lookups are very fast
4. **Consistent**: Same course always generates same hash
5. **Debuggable**: Hash generation is deterministic and testable

## 📊 Hash Collision Handling

The system uses a 64-bit hash space (16 hex characters) which provides:
- **Extremely low collision probability**: ~1 in 18 quintillion
- **Fast comparison**: String comparison of 16 characters
- **Human readable**: Hex strings are debuggable

For the scale of golf courses (~50,000 worldwide), hash collisions are essentially impossible.

## 🔮 Future Enhancements

Potential improvements:
- Add geographic boundaries to normalization
- Include course type in hash (public/private/resort)
- Add phone number as secondary identifier
- Implement fuzzy matching for similar courses 