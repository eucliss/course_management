package config

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"log"
	"os"
	"strings"
)

// SecretManager handles secure secret management
type SecretManager struct {
	config *Config
}

// NewSecretManager creates a new secret manager
func NewSecretManager(config *Config) *SecretManager {
	return &SecretManager{config: config}
}

// GenerateSecureSecret generates a cryptographically secure random secret
func GenerateSecureSecret(length int) (string, error) {
	if length < 16 {
		return "", fmt.Errorf("secret length must be at least 16 characters")
	}

	// Generate random bytes
	bytes := make([]byte, length)
	if _, err := rand.Read(bytes); err != nil {
		return "", fmt.Errorf("failed to generate random bytes: %w", err)
	}

	// Encode to base64 and trim to desired length
	secret := base64.URLEncoding.EncodeToString(bytes)
	if len(secret) > length {
		secret = secret[:length]
	}

	return secret, nil
}

// ValidateSecrets validates that all required secrets are properly configured
func (sm *SecretManager) ValidateSecrets() error {
	var errors []string

	// Validate session secret
	if err := sm.validateSecret("SESSION_SECRET", sm.config.Security.SessionSecret, 32); err != nil {
		errors = append(errors, err.Error())
	}

	// Validate CSRF secret in production
	if sm.config.IsProduction() {
		if err := sm.validateSecret("CSRF_SECRET", sm.config.Security.CSRFSecret, 16); err != nil {
			errors = append(errors, err.Error())
		}
	}

	// Validate JWT secret if configured
	if sm.config.Security.JWTSecret != "" {
		if err := sm.validateSecret("JWT_SECRET", sm.config.Security.JWTSecret, 32); err != nil {
			errors = append(errors, err.Error())
		}
	}

	// Validate Google OAuth secrets in production
	if sm.config.IsProduction() {
		if sm.config.Google.ClientID == "" {
			errors = append(errors, "GOOGLE_CLIENT_ID is required in production")
		}
		if sm.config.Google.ClientSecret == "" {
			errors = append(errors, "GOOGLE_CLIENT_SECRET is required in production")
		}
	}

	// Validate database password in production
	if sm.config.IsProduction() && sm.config.Database.Password == "" {
		errors = append(errors, "DB_PASSWORD is required in production")
	}

	if len(errors) > 0 {
		return fmt.Errorf("secret validation failed: %s", strings.Join(errors, "; "))
	}

	return nil
}

// validateSecret validates a single secret
func (sm *SecretManager) validateSecret(name, value string, minLength int) error {
	if value == "" {
		return fmt.Errorf("%s is required", name)
	}

	if len(value) < minLength {
		return fmt.Errorf("%s must be at least %d characters long", name, minLength)
	}

	// Check for common weak secrets
	weakSecrets := []string{
		"secret",
		"password",
		"changeme",
		"default",
		"development",
		"testing",
		"production",
		"admin",
		"user",
		"123456",
	}

	lowerValue := strings.ToLower(value)
	for _, weak := range weakSecrets {
		if strings.Contains(lowerValue, weak) && sm.config.IsProduction() {
			return fmt.Errorf("%s appears to contain weak patterns and should be changed in production", name)
		}
	}

	return nil
}

// GenerateSecretsFile generates a secure secrets file for a given environment
func GenerateSecretsFile(environment string) error {
	secrets := make(map[string]string)

	// Generate secure secrets
	sessionSecret, err := GenerateSecureSecret(64)
	if err != nil {
		return fmt.Errorf("failed to generate session secret: %w", err)
	}
	secrets["SESSION_SECRET"] = sessionSecret

	csrfSecret, err := GenerateSecureSecret(32)
	if err != nil {
		return fmt.Errorf("failed to generate CSRF secret: %w", err)
	}
	secrets["CSRF_SECRET"] = csrfSecret

	jwtSecret, err := GenerateSecureSecret(64)
	if err != nil {
		return fmt.Errorf("failed to generate JWT secret: %w", err)
	}
	secrets["JWT_SECRET"] = jwtSecret

	// Create secrets file
	filename := fmt.Sprintf("config/%s.secrets.env", environment)
	content := fmt.Sprintf(`# Generated secrets for %s environment
# WARNING: Keep this file secure and never commit to version control!
# Generated on: %s

# Session management secrets
SESSION_SECRET=%s
CSRF_SECRET=%s
JWT_SECRET=%s

# Database configuration (fill in your values)
DB_PASSWORD=your_secure_database_password_here

# Google OAuth configuration (fill in your values)
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret

# Mapbox configuration (fill in your values)
MAPBOX_ACCESS_TOKEN=your_mapbox_access_token

# Additional production secrets
# Add other sensitive configuration here
`,
		environment,
		"generated by course management system",
		secrets["SESSION_SECRET"],
		secrets["CSRF_SECRET"],
		secrets["JWT_SECRET"],
	)

	if err := os.WriteFile(filename, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write secrets file: %w", err)
	}

	log.Printf("Generated secure secrets file: %s", filename)
	log.Printf("IMPORTANT: Keep this file secure and add it to .gitignore!")

	return nil
}

// LoadSecretsFromFile loads secrets from a separate secrets file
func LoadSecretsFromFile(environment string) error {
	secretsFile := fmt.Sprintf("config/%s.secrets.env", environment)
	return loadEnvFile(secretsFile)
}

// CheckSecretsSetup checks if secrets are properly configured
func CheckSecretsSetup(environment string) {
	log.Printf("🔒 Checking secrets configuration for %s environment...", environment)

	// Load configuration
	config, err := LoadConfig()
	if err != nil {
		log.Printf("❌ Failed to load configuration: %v", err)
		return
	}

	// Validate secrets
	secretManager := NewSecretManager(config)
	if err := secretManager.ValidateSecrets(); err != nil {
		log.Printf("❌ Secret validation failed: %v", err)
		
		if environment == "production" {
			log.Printf("💡 For production, ensure all secrets are properly configured")
			log.Printf("💡 Run: go run cmd/generate-secrets/main.go --env=production")
		}
		return
	}

	log.Printf("✅ All secrets are properly configured")
}

// GetRequiredSecrets returns a list of required secrets for an environment
func GetRequiredSecrets(environment string) []string {
	base := []string{
		"SESSION_SECRET",
	}

	if environment == "production" {
		return append(base, []string{
			"CSRF_SECRET",
			"DB_PASSWORD",
			"GOOGLE_CLIENT_ID",
			"GOOGLE_CLIENT_SECRET",
		}...)
	}

	return base
}

// MaskSecret masks a secret for logging (shows first 4 and last 4 characters)
func MaskSecret(secret string) string {
	if len(secret) <= 8 {
		return "***"
	}
	return secret[:4] + "***" + secret[len(secret)-4:]
}